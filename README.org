#+STARTUP: showall
#+TITLE: CFFI bindings to the IUP Portable User Interface library

* Introduction

Note: If you're using SBCL, you'll need to set a larger heap size to
compile the bindings, e.g. ~--dynamic-space-size 2048~

#+begin_src lisp :results silent
  (ql:quickload "iup")
#+end_src

* Hello, World!

#+begin_src lisp :results silent :export none :tangle examples/hello.lisp
  (defpackage #:iup-examples.hello
    (:use #:common-lisp)
    (:export #:hello))

  (in-package #:iup-examples.hello)
#+end_src

#+begin_src lisp :results silent :tangle examples/hello.lisp
  (defun hello ()
    (iup:with-iup ()
      (let* ((label (iup:label :title (format nil "Hello, World!~%IUP ~A~%~A ~A"
					      (iup:version)
					      (lisp-implementation-type)
					      (lisp-implementation-version))))
	     (dialog (iup:dialog label :title "Hello, World!")))
	(iup:show dialog)
	(iup:main-loop))))
#+end_src

#+begin_src lisp :results silent :tangle examples/hello.lisp
  #-sbcl (hello)

  ,#+sbcl
  (sb-int:with-float-traps-masked
      (:divide-by-zero :invalid)
    (hello))
#+end_src

[[./docs/screenshots/helloworld.png]] [[./docs/screenshots/helloworld-2.png]]

* Callbacks

#+begin_src lisp :results silent :export none :tangle examples/callback.lisp
  (defpackage #:iup-examples.callback
    (:use #:common-lisp)
    (:export #:callback))

  (in-package #:iup-examples.callback)
#+end_src

#+begin_src lisp :results silent :tangle examples/callback.lisp
  (defun callback ()
      (iup:with-iup ()
	(let* ((button
		 (iup:button :title "&OK"
			     :expand "YES"
			     :tip "Exit button"
			     :action (lambda (handle)
				       (iup:message "Message"
						    (lisp-implementation-version))
				       iup:+close+)))
	       (label (iup:label :title (lisp-implementation-type)))
	       (vbox (iup:vbox (list label button)
			       :gap "10"
			       :margin "10x10"
			       :alignment :acenter))
	       (dialog (iup:dialog vbox :title "Hello, World!")))
	  (iup:show dialog)
	  (iup:main-loop))))
#+end_src

#+begin_src lisp :results silent :tangle examples/callback.lisp
  #-sbcl (hello)

  ,#+sbcl
  (sb-int:with-float-traps-masked
      (:divide-by-zero :invalid)
    (callback))
#+end_src

[[./docs/screenshots/callback-1.png]] [[./docs/screenshots/callback-2.png]]

[[./docs/screenshots/callback-3.png]] [[./docs/screenshots/callback-4.png]]

* Canvas

In this example, we'll port the Sierpinski Carpet fractal that
appeared the chapter on graphics in [[https://www.apress.com/us/book/9781484211779][Common Lisp Recipes: A
Problem-Solution Approach]].

We need a spinner (an up and down arrow-controlled number field) and a
canvas to draw on to get started. In this example, rather than specify
the callbacks inline, as anonymous lamba forms, we will create
separate functions and set them later using ~(SETF
IUP:CALLBACK)~. ~*LEVELS*~ will keep track how deep to draw the
fractal.

#+begin_src lisp :results silent :export none :tangle examples/sierpinski.lisp
  (defpackage #:iup-examples.sierpinksi
    (:use #:common-lisp)
    (:export #:sierpinksi))

  (in-package #:iup-examples.sierpinksi)
#+end_src

#+begin_src lisp :results silent
  (defparameter *levels* 0)

  (defun sierpinski ()
    (iup:with-iup ()
      (let* ((canvas (iup:canvas :rastersize "200x200"))
             (spin (iup:text :spin "YES" :spinmin 0 :spinmax 4))
             (vbox (iup:vbox (list canvas spin) :alignment "ACENTER"))
             (dialog (iup:dialog vbox :title "Sierpinski Carpet")))
        (setf (iup:callback canvas :map_cb) 'canvas-map
              (iup:callback canvas :unmap_cb) 'canvas-unmap
              (iup:callback canvas :action) 'canvas-redraw
              (iup:callback spin :spin_cb) 'canvas-spin
              ,*levels* 0)
        (iup:show-xy dialog iup:+center+ iup:+center+)
        (iup:main-loop))))
#+end_src

** Notes on Callback Naming

Each IUP widget supports a number of callbacks. In IUP, these are
strings. In the Lisp bindings, they can be specified as keywords. For
example, ~:UNMAP_CB~. These are rather unlispy names, but do come from
IUP via its introspection mechanism. In a future version of these
bindings, it might be possible to have lispier
names. e.g. ~:UNMAP-CALLBACK~.

** CD, a 2D Graphics Library

IUP has support for CD, a cross platform 2D Graphics Library. We have
support in Lisp via [[https://github.com/lispnik/cd][CD]] bindings.

#+begin_src lisp :results silent
  (ql:quickload "cd")
#+end_src

The following code is entirely CD dependent and can be used in non-IUP
canvas applications.

#+caption: Adapted from Edi's LTK example in Common Lisp Recipes: A Problem-Solution Approach
#+begin_src lisp :results silent
  (defun sierpinski-draw (canvas level)
    (multiple-value-bind
          (w h)
        (cd:size canvas)
      (labels ((square (x y x-size y-size)
                 (cd:box canvas x (+ x x-size) y (+ y y-size)))
               (recurse (x y x-size y-size level)
                 (let ((x-step (/ x-size 3))
                       (y-step (/ y-size 3)))
                   (square (+ x x-step) (+ y y-step) x-step y-step)
                   (when (plusp level)
                     (dolist (x-next (list x (+ x x-step) (+ x x-step x-step)))
                       (dolist (y-next (list y (+ y y-step) (+ y y-step y-step)))
                         (recurse x-next y-next x-step y-step (1- level))))))))
        (recurse 0 0 w h level))))
#+end_src

For example, we can write it to [[./docs/sierpinski.pdf][PDF]] and print out to hang on your
wall:

#+begin_src lisp :results silent
  (ql:quickload "cd-pdf")

  (let ((canvas (cd:create-canvas (cd-pdf:context-pdf) "docs/sierpinski.pdf")))
    (unwind-protect
	 (sierpinski-draw canvas 4)
      (cd:kill canvas)))
#+end_src

In our IUP example however, we'll use it with IUP's CD support and
arrange for the canvas to be draw on via ~CANVAS-REDRAW~ which will be
triggered by the canvas widget's action callback.

#+begin_src lisp :results silent
  (ql:quickload "iup-cd")
#+end_src

#+begin_src lisp :results silent :tangle examples/sierpinski.lisp
  (defparameter *canvas* nil)

  (defun canvas-redraw (handle x y)
    (cd:activate *canvas*)
    (cd:clear *canvas*)
    (setf (cd:foreground *canvas*) cd:+red+)
    (sierpinski-draw *canvas* *levels*)
    (cd:flush *canvas*)
    iup:+default+)
#+end_src

We can ignore ~HANDLE~, ~X~, and ~Y~ in our callback handler in this
example. Those are IUP widget that triggered the callback and location
on the canvas.

First we activate the canvas to draw on, clear whatever was there, set
a drawing color for the the foreground of the canvas, then draw to the
canvas using ~SIERPINSKI-DRAW~.

The last step is to flush the canvas. This triggers a backing buffer
swap, so all of the drawing appears instantly. If we don't do this, we
don't see anything on the screen because it will still be in the
off-screen drawing buffer.

** Attributes

It is a good idea to separate your UI presentation from its undelying
model. In our case, the UI "model" is a special variable ~*LEVELS*~
which holds the depth to draw the fractal as an integer. We need this
updated when the user clicks on the spinner widget.

#+begin_src lisp :results silent :tangele examples/sierpinski.lisp
  (defun canvas-spin (handle pos)
    (setf *levels* (iup:attribute handle :value 'integer))
    (canvas-redraw nil nil nil)
    iup:+default+)
#+end_src

We can get the number from the spinner widget and assign it to
~*LEVELS*~ using ~IUP:ATTRIBUTE~. It takes a IUP handle from which to
get the ~:VALUE~ attribute. 

IUP widget value attributes are mostly strings. The third argument,
~'INTEGER~ converts the string to an integer for convenience, rather
than having to ~PARSE-INTEGER~ ourselves.

** Fiddly bits

Lastly, we need to associate the CD canvas with a IUP canvas, but we
can't do this until we have the handle of the IUP canvas, so we can't
set it up in the ~LET*~ form in our main function like we did with
everything else. 

Luckily IUP provides callbacks for when the component is "mapped" onto
the user's display which allow us to deal with this dependency in an
elegant manner.

#+begin_src lisp :results silent :tangle examples/sierpinski.lisp
  (defun canvas-map (handle)
    (setf *canvas* (cd:create-canvas (iup-cd:context-iup-dbuffer) handle))
    iup:+default+)

  (defun canvas-unmap (handle)
    (cd:kill *canvas*)
    iup:+default+)
#+end_src

#+begin_src lisp :results silent :tangle examples/sierpinksi.lisp
  #-sbcl (sierpinski)

  ,#+sbcl
  (sb-int:with-float-traps-masked
      (:divide-by-zero :invalid)
    (sierpinski))
#+end_src

[[./docs/screenshots/sierpinski.png]][[./docs/screenshots/sierpinski-02.png]]

* Using IUP Additional Controls

The [[https://www.tecgraf.puc-rio.br/iup/en/ctrl/iupcells.html][cells control]] "creates a grid widget (set of cells) that enables
several application-specific drawing, such as: chess tables, tiles
editors, degrade scales, drawable spreadsheets and so forth".

It's included in the standard IUP distribution downloads, but it's not
automatically loaded. The Lisp bindings do the same thing, so to use
it, we need to depend on ~IUP-CONTROLS~.

#+begin_src lisp :results silent
  (ql:quickload '("iup" "iup-controls" "cd"))
#+end_src 

#+begin_src lisp :results silent :export none :tangle examples/cells.lisp
  (defpackage #:iup-examples.cells-checkerboard
    (:use #:common-lisp)
    (:export #:cells-checkerboard))

  (in-package #:iup-examples.cells-checkerboard)
#+end_src

We start with the same boiler plate, but this time we need to call
~IUP-CONTROLS:OPEN~ ahead of using the cells control.

#+begin_src lisp :results silent :tangle examples/cells.lisp
  (defun cells-checkerboard ()
    (iup:with-iup ()
      (iup-controls:open)
      (let* ((cells (iup-controls:cells
                     :draw_cb 'draw
                     :width_cb 'width
                     :height_cb 'height
                     :nlines_cb 'nlines
                     :ncols_cb 'ncols
                     :mouseclick_cb 'click))
             (vbox (iup:vbox (list cells)))
             (dialog (iup:dialog vbox :title "Cells Checkerboard" :rastersize "440x480" :shrink "YES")))
        (iup:show-xy dialog iup:+center+ iup:+center+)
        (iup:main-loop))))
#+end_src

Cells has a number of callbacks related rows, columns, sizing etc.

#+begin_src lisp :results silent :tangle examples/cells.lisp
  (defun nlines (handle) 8)
  (defun ncols (handle) 8)
  (defun height (handle i) 50)
  (defun width (handle j) 50)
#+end_src

When ~DRAW~ is called, we get a canvas on which to draw:

#+begin_src lisp :results silent :tangle examples/cells.lisp
  (defun draw (handle i j xmin xmax ymin ymax canvas)
    (if (or (and (oddp i) (oddp j)) (and (oddp (1+ i)) (oddp (1+ j))))
        (setf (cd:foreground canvas) cd:+black+)
        (setf (cd:foreground canvas) cd:+white+))
    (cd:box canvas xmin xmax ymin ymax)
    iup::+default+)
#+end_src

When out click callback is called:

#+begin_src lisp :results silent :tangle examples/cells.lisp
  (defun click (handle button pressed line column x y status)
    (iup:message
     "Clicked!"
     (format nil "Callback arguments~%~S"
      (list :button button
            :pressed pressed
            :line line
            :column column
            :x x
            :y y
            :status (iup:status-plist status))))
       iup:+default+)
#+end_src

#+begin_src lisp :results silent :export none :tangle examples/cells.lisp
  #-sbcl (cells-checkerboard)

  ,#+sbcl
  (sb-int:with-float-traps-masked
      (:divide-by-zero :invalid)
    (cells-checkerboard))
#+end_src

[[./docs/screenshots/checkerboard-01.png]] 
[[./docs/screenshots/checkerboard-02.png]]

[[./docs/screenshots/checkerboard-03.png]] 
[[./docs/screenshots/checkerboard-04.png]] 

(lol button 49)

* Detachable Box

#+begin_src lisp :results silent :export none :tangle examples/detached.lisp
  (defpackage #:iup-examples.detached
    (:use #:common-lisp)
    (:export #:detached))

  (in-package #:iup-examples.detached)
#+end_src

#+begin_src lisp :results silent :tangle examples/detached.lisp
  (defun detached ()
    (iup:with-iup ()
      (let* ((button1 (iup:button :title "Detach Me!"
                                  :action 'button-detach-callback
                                  :expand :yes
                                  :handlename "detach"))
             (multi-line (iup:multi-line :expand :yes
                                         :visiblelines 5))
             (hbox (iup:hbox (list button1 multi-line) :margin "10x0"))
             (dbox (iup:detach-box hbox :orientation :vertical
                                        :detached_cb 'detached-callback
                                        :handlename "dbox"))
             (label (iup:label :title "Label"
                               :expand :vertical))
             (button2 (iup:button :title "Restore me!"
                                  :expand :yes
                                  :active :no
                                  :action 'button-restore-callback
                                  :handlename "restore"))
             (text (iup:text :expand :horizontal))
             (dialog (iup:dialog (iup:vbox (list dbox label button2 text)
                                           :margin "10x10"
                                           :gap 10)
                                 :title "IupDetachBox Example"
                                 :rastersize "300x300")))

        (iup:show dialog)
        (iup:main-loop))))
#+end_src

** Handle Names

Instead of accessing other elements via lexical scope, it's sometimes
useful to refer to them by name. This example uses the ~HANDLENAME~
attribute to associate a name with an IUP handle.

#+begin_src lisp :results silent :tangle examples/detached.lisp
  (defun detached-callback (handle new-parent x y)
    (setf (iup:attribute new-parent :title) "New Dialog"
          (iup:attribute (iup:handle "restore") :active) :yes
          (iup:attribute (iup:handle "detach") :active) :no)
    iup:+default+)

  (defun button-restore-callback (button)
    (setf (iup:attribute (iup:handle "dbox") :restore) nil
          (iup:attribute button :active) :no
          (iup:attribute (iup:handle "detach") :active) :yes)
    iup:+default+)

  (defun button-detach-callback (button)
    (setf (iup:attribute (iup:handle "dbox") :detach) nil
          (iup:attribute button :active) :no
          (iup:attribute (iup:handle "restore") :active) :yes)
    iup:+default+)
#+end_src

#+begin_src lisp :results silent :export none :tangle examples/detached.lisp
  #-sbcl (detached)

  ,#+sbcl
  (sb-int:with-float-traps-masked
      (:divide-by-zero :invalid)
    (detached))
#+end_src

[[./docs/screenshots/detach-01.png]]

# FIXME look into problem with restore not being active after detach
# FIXME insert example of using restart to recover from error in callback

* Tabs Example

Demonstrates the use of ~(SETF IUP:ATTRIBUTE)~ for setting attributes
not available via control's constructor function.

#+begin_src lisp :results silent :export none :tangle examples/tabs.lisp
  (defpackage #:iup-examples.tabs
    (:use #:common-lisp)
    (:export #:tabs))

  (in-package #:iup-examples.tabs)
#+end_src

#+begin_src lisp :results silent :tangle examples/tabs.lisp
  (defun tabs ()
    (iup:with-iup ()
      (let* ((vbox1 (iup:vbox
                     (list (iup:label :title "Inside Tab A")
                           (iup:button :title "Button A"))))
             (vbox2 (iup:vbox
                     (list (iup:label :title "Inside Tab B")
                           (iup:button :title "Button B"))))
             (tabs1 (iup:tabs (list vbox1 vbox2)))
             (vbox3 (iup:vbox
                     (list (iup:label :title "Inside C")
                           (iup:button :title "Button C"))))
             (vbox4 (iup:vbox
                     (list (iup:label :title "Inside D")
                           (iup:button :title "Button D"))))
             (tabs2 (iup:tabs (list vbox3 vbox4)))
             (box (iup:hbox (list tabs1 tabs2) :margin "10x10" :gap "10"))
             (dialog (iup:dialog box :title "IUP Tabs" :size "200x80")))
        (setf (iup:attribute vbox1 :tabtitle) "Tab A"
              (iup:attribute vbox2 :tabtitle) "Tab B"
              (iup:attribute vbox3 :tabtitle) "Tab C"
              (iup:attribute vbox4 :tabtitle) "Tab D")
        (iup:show dialog)
        (iup:main-loop))))
#+end_src

#+begin_src lisp :results silent :export none
  #-sbcl (tabs)

  ,#+sbcl
  (sb-int:with-float-traps-masked
      (:divide-by-zero :invalid)
    (tabs))
#+end_src 

[[./docs/screenshots/tabs-01.png]] [[./docs/screenshots/tabs-02.png]]

* OpenGL

For this example, we'll take advantage for [[https://github.com/3b/cl-opengl][cl-opengland and
cl-glu]]. Don't forget to depend on iup-gl (part of these bindings) as
well.

#+begin_src lisp :results silent
  (ql:quickload '("iup-gl" "cl-opengl" "cl-glu"))
#+end_src

Much of this example is tedious old-style OpenGL. We'll only highlight
the IUP/OpenGL integration points here. It suffices to say, we've got
a function ~CUBE~ which draws OpenGL things to the current buffer.

#+begin_src lisp :export none :results silent :tangle examples/cube.lisp
  (defpackage #:iup-examples.cube
    (:use #:common-lisp))

  (in-package #:iup-examples.cube)
#+end_src

#+begin_src lisp :results silent :tangle examples/cube.lisp
  (defvar *canvas* nil)
  (defvar *tt* 0.0)

  (defvar *vertices*
    #((-1 -1 1) (-1 1 1)
      (1 1 1) (1 -1 1)
      (-1 -1 -1) (-1 1 -1)
      (1 1 -1) (1 -1 -1)))

  (defun polygon (a b c d)
    (gl:begin :polygon)
    (apply #'gl:vertex (aref *vertices* a))
    (apply #'gl:vertex (aref *vertices* b))
    (apply #'gl:vertex (aref *vertices* c))
    (apply #'gl:vertex (aref *vertices* d))
    (gl:end))

  (defun color-cube ()
    (gl:color 1 0 0)
    (gl:normal 1 0 0)
    (polygon 2 3 7 6)
    (gl:color 0 1 0)
    (gl:normal 0 1 0)
    (polygon 1 2 6 5)
    (gl:color 0 0 1)
    (gl:normal 0 0 1)
    (polygon 0 3 2 1)
    (gl:color 1 0 1)
    (gl:normal 0 -1 0)
    (polygon 3 0 4 7)
    (gl:color 1 1 0)
    (gl:normal 0 0 -1)
    (polygon 4 5 6 7)
    (gl:color 0 1 1)
    (gl:normal -1 0 0)
    (polygon 5 4 0 1))
#+end_src

#+begin_src lisp :results silent :tangle examples/cube.lisp
  (defun cube ()
    (iup:with-iup ()
      (iup-gl:open)
      (setf *canvas*
            (iup-gl:canvas :rastersize "640x480"
                           :buffer "DOUBLE"
                           :action 'repaint
                           :resize_cb 'resize))
      (let* ((dialog (iup:dialog *canvas* :title "IUP OpenGL")))
        ;; FIXME      (iup-cffi::%iup-set-function :idle_action 'idle)
        (setf (iup:attribute *canvas* :depthsize) "16")
        (iup:show dialog)
        (iup:main-loop))))
#+end_src

Our example has three callbacks: repaint, resize and a global idle
function callback which we'll use to rotate a cube relative to time
variable ~*TT*~.

#+begin_src lisp :results silent :tangle examples/cube.lisp
  (defun repaint (handle posx posy)
    (iup-gl:make-current handle)
    (gl:clear-color 0.3 0.3 0.3 1.0)
    (gl:clear :color-buffer-bit :depth-buffer-bit)
    (gl:enable :depth-test)
    (gl:matrix-mode :modelview)
    (gl:with-pushed-matrix
      (gl:translate 0 0 0)
      (gl:scale 1 1 1)
      (gl:rotate *tt* 0 0 1)
      (color-cube))
    (iup-gl:swap-buffers handle)
    iup::+default+)

  (defun resize (handle width height)
    (iup-gl:make-current handle)
    (gl:viewport 0 0 width height)
    (gl:matrix-mode :modelview)
    (gl:load-identity)
    (gl:matrix-mode :projection)
    (gl:load-identity)
    (glu:perspective 60 (/ 4 3) 1 15)
    (glu:look-at 3 3 3 0 0 0 0 0 1)
    iup::+default+)
#+end_src

#+begin_src lisp :results silent :tangle examples/cube.lisp
  ;;; FIXME
  ;; (cffi:defcallback idle-cb :int ()
  ;;   (incf tt)
  ;;   (iup-gl:make-current canvas)
  ;;   (repaint canvas)
  ;;   iup::+default+)
#+end_src

#+begin_src lisp :results silent :export none
  #-sbcl (cube)

  ,#+sbcl
  (sb-int:with-float-traps-masked
      (:divide-by-zero :invalid)
    (cube))
#+end_src

[[./docs/screenshots/opengl.png]]

[[./docs/screenshots/opengl-01.png]]

* Bindings Generation Internals

There are dozens of IUP controls and each control has dozens of
callbacks and attributes. Fortunately IUP controls can be introspected
to gain information on what the control is, what its callbacks and
attributes are (and their arguments and types). 

The "iup-classesdb" system uses this information to to automatically
generate binding metadata from which the bindings are generated. This
provides for a much nicer development experience:

[[./docs/screenshots/generation-01.png]]

The following sections describe how this works in more detail.

** Maintainer

The maintainer is typically someone with access to the Git repository
for these bindings. When a new release of IUP comes out, the
maintainer needs to update the metadata so that any new or removed
controls, attributes or callbacks are reflected in the Lisp bindings:

#+begin_src plantuml :file docs/binding-maintainer.png :results silent
  (*) --> "(asdf:load-system :iup-classesdb)" as Load
  Load --> "(iup-classesdb:regenerate)" as Regen
  Regen --> "classesdb.lisp-sexp" as Sexp
  Sexp --> (*)
#+end_src

[[./docs/binding-maintainer.png]]

[[file:classesdb.lisp-sexp][~classesdb.lisp-sexp~]] is the output metadata. The maintainer typically
commits this file to version control so the metadata is available for
everyone.

** User

The first time the user compiles the IUP bindings,
~classesdb.lisp-sexp~ is processed by macros at compile time and
generates all function definitions for IUP controls. Note, that
~classesdb.lisp-sexpr~ is not actually needed when the user loads the
system.

For the curious, the generation looks like the following, for each IUP
system: ~IUP~, ~IUP-CONTROLS~, ~IUP-GL~, ~IUP-GLCONTROLS~, ~IUP-PLOT~,
~IUP-MGLPLOT~, ~IUP-OLECONTROL~, ~IUP-SCINTILLA~, ~IUP-WEB~ and
~IUP-TUIO~.

#+begin_src lisp :results silent :export none
  (iup::defiupclasses "IUP")
#+end_src

The process is roughly: 

1. load each shared library
2. introspect for the available IUP classes (i.e. metadata about
   controls) availabe
3. For each class, generate the bindings in its own package.

#+begin_src plantuml :file docs/binding-generation.png :results silent
  (*) --> "(asdf:compile-system :iup)" as Load
  "classesdb.lisp-sexp" as Sexpr --> Load
  Load --> (*)
#+end_src

#+begin_src plantuml :file docs/binding-generation-2.png :results silent
  (*) --> "(asdf:load-system :iup)" as Load
  Load --> (*)
#+end_src

 [[./docs/binding-generation.png]][[./docs/binding-generation-2.png]]

** Why ~classesdb.lisp-sexp~?

Extracting the metadata actually requires a complete GUI stack
running. On Linux, this means having an X11 display available. This
turns out to be a bit of a problem for continuous integration
systems.

Although there are embedded X11 servers that can be used, I didn't
know what might be necessary for Windows or even macOS (when it's
supported) for CI/CD. Hence the ~classesdb.lisp-sexp~ is the
maintainer's job to regenerate when necessary.

** Example IUP 3.25 to 3.26

Amongt other changes, IUP 3.26 introduced [[http://webserver2.tecgraf.puc-rio.br/iup/en/elem/iupmultibox.html][IupMultiBox]] as a new control
container with 19 attributes and defaults. Regenerating
~classesdb.lisp-sexp~ automatically collected these changes so that
the corresponding Lisp function ~IUP:MULTIBOX~ is created and exported
automatically from the ~IUP~ package.

* Interactive Development

TBD

* LED
