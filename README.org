#+STARTUP: showall
#+TITLE: CFFI bindings to the IUP Portable User Interface library

* Introduction

#+begin_src lisp :results silent
  (ql:quickload "iup")
#+end_src

* Hello, World!

#+begin_src lisp :results silent
  (iup:with-iup ()
    (let* ((label (iup:label :title (format nil "Hello, World!~%IUP ~A~%~A ~A"
                                            (iup:version)
                                            (lisp-implementation-type)
                                            (lisp-implementation-version))))
           (dialog (iup:dialog label :title "Hello, World!")))
      (iup:show dialog)
      (iup:main-loop)))
#+end_src

[[./docs/screenshots/helloworld.png]] [[./docs/screenshots/helloworld-2.png]]

* Callbacks

#+begin_src lisp :results silent
  (iup:with-iup ()
    (let* ((button
             (iup:button :title "&OK"
                         :expand "YES"
                         :tip "Exit button"
                         :action (lambda (handle)
                                   (iup:message "Message"
                                                (lisp-implementation-version))
                                   iup:+close+)))
           (label (iup:label :title (lisp-implementation-type)))
           (vbox (iup:vbox (list label button)
                           :gap "10"
                           :margin "10x10"
                           :alignment :acenter))
           (dialog (iup:dialog vbox :title "Hello, World!")))
      (iup:show dialog)
      (iup:main-loop)))
#+end_src

[[./docs/screenshots/callback-1.png]] [[./docs/screenshots/callback-2.png]]

[[./docs/screenshots/callback-3.png]] [[./docs/screenshots/callback-4.png]]

* Canvas

In this example, we'll port the Sierpinski Carpet fractal that
appeared the chapter on graphics in [[https://www.apress.com/us/book/9781484211779][Common Lisp Recipes: A
Problem-Solution Approach]].

We need a spinner (an up and down arrow-controlled number field) and a
canvas to draw on to get started. In this example, rather than specify
the callbacks inline, as anonymous lamba forms, we will create
separate functions and set them later using ~(SETF
IUP:CALLBACK)~. ~*LEVELS*~ will keep track how deep to draw the
fractal.

#+begin_src lisp :results silent
  (defparameter *levels* 0)

  (defun sierpinski-main ()
    (iup:with-iup ()
      (let* ((canvas (iup:canvas :rastersize "200x200"))
             (spin (iup:text :spin "YES" :spinmin 0 :spinmax 4))
             (vbox (iup:vbox (list canvas spin) :alignment "ACENTER"))
             (dialog (iup:dialog vbox :title "Sierpinski Carpet")))
        (setf (iup:callback canvas :map_cb) 'canvas-map
              (iup:callback canvas :unmap_cb) 'canvas-unmap
              (iup:callback canvas :action) 'canvas-redraw
              (iup:callback spin :spin_cb) 'canvas-spin
              ,*levels* 0)
        (iup:show-xy dialog iup:+center+ iup:+center+)
        (iup:main-loop))))
#+end_src

** Notes on Callback Naming

Each IUP widget supports a number of callbacks. In IUP, these are
strings. In the Lisp bindings, they can be specified as keywords. For
example, ~:UNMAP_CB~. These are rather unlispy names, but do come from
IUP via its introspection mechanism. In a future version of these
bindings, it might be possible to have lispier
names. e.g. ~:UNMAP-CALLBACK~.

** CD, a 2D Graphics Library

IUP has support for CD, a cross platform 2D Graphics Library. We have
support in Lisp via [[https://github.com/lispnik/cd][CD]] bindings.

#+begin_src lisp :results silent
  (ql:quickload "cd")
#+end_src

The following code is entirely CD dependent and can be used in non-IUP
canvas applications.

#+caption: Adapted from Edi's LTK example in Common Lisp Recipes: A Problem-Solution Approach
#+begin_src lisp :results silent
  (defun sierpinski (canvas level)
    (multiple-value-bind
          (w h)
        (cd:size canvas)
      (labels ((square (x y x-size y-size)
                 (cd:box canvas x (+ x x-size) y (+ y y-size)))
               (recurse (x y x-size y-size level)
                 (let ((x-step (/ x-size 3))
                       (y-step (/ y-size 3)))
                   (square (+ x x-step) (+ y y-step) x-step y-step)
                   (when (plusp level)
                     (dolist (x-next (list x (+ x x-step) (+ x x-step x-step)))
                       (dolist (y-next (list y (+ y y-step) (+ y y-step y-step)))
                         (recurse x-next y-next x-step y-step (1- level))))))))
        (recurse 0 0 w h level))))
#+end_src

For example, we can write it to [[./docs/sierpinski.pdf][PDF]] and print out to hang on your
wall:

#+begin_src lisp
  (ql:quickload "cd-pdf")

  (let ((canvas (cd:create-canvas (cd-pdf:context-pdf) "sierpinski.pdf")))
    (unwind-protect
         (sierpinski canvas 4)
      (cd:kill canvas)))
#+end_src

#+RESULTS:
: NIL

In our IUP example however, we'll use it with IUP's CD support and
arrange for the canvas to be draw on via ~CANVAS-REDRAW~ which will be
triggered by the canvas widget's action callback.

#+begin_src lisp :results silent
  (ql:quickload "iup-cd")
#+end_src

#+begin_src lisp :results silent
  (defparameter *canvas* nil)

  (defun canvas-redraw (handle x y)
    (cd:activate *canvas*)
    (cd:clear *canvas*)
    (setf (cd:foreground *canvas*) cd:+red+)
    (sierpinski *canvas* *levels*)
    (cd:flush *canvas*)
    iup:+default+)
#+end_src

We can ignore ~HANDLE~, ~X~, and ~Y~ in our callback handler in this
example. Those are IUP widget that triggered the callback and location
on the canvas.

First we activate the canvas to draw on, clear whatever was there, set
a drawing color for the the foreground of the canvas, then draw to the
canvas using ~SIERPINSKI~.

The last step is to flush the canvas. This triggers a backing buffer
swap, so all of the drawing appears instantly. If we don't do this, we
don't see anything on the screen because it will still be in the
off-screen drawing buffer.

** Attributes

It is a good idea to separate your UI presentation from its undelying
model. In our case, the UI "model" is a special variable ~*LEVELS*~
which holds the depth to draw the fractal as an integer. We need this
updated when the user clicks on the spinner widget.

#+begin_src lisp :results silent
  (defun canvas-spin (handle pos)
    (setf *levels* (iup:attribute handle :value 'integer))
    (canvas-redraw nil nil nil)
    iup:+default+)
#+end_src

We can get the number from the spinner widget and assign it to
~*LEVELS*~ using ~IUP:ATTRIBUTE~. It takes a IUP handle from which to
get the ~:VALUE~ attribute. 

IUP widget value attributes are mostly strings. The third argument,
~'INTEGER~ converts the string to an integer for convenience, rather
than having to ~PARSE-INTEGER~ ourselves.

** Fiddly bits

Lastly, we need to associate the CD canvas with a IUP canvas, but we
can't do this until we have the handle of the IUP canvas, so we can't
set it up in the ~LET*~ form in our main function like we did with
everything else. 

Luckily IUP provides callbacks for when the component is "mapped" onto
the user's display which allow us to deal with this dependency in an
elegant manner.

#+begin_src lisp :results silent
  (defun canvas-map (handle)
    (setf *canvas* (cd:create-canvas (iup-cd:context-iup-dbuffer) handle))
    iup:+default+)

  (defun canvas-unmap (handle)
    (cd:kill *canvas*)
    iup:+default+)
#+end_src

#+begin_src lisp :results silent
  (sierpinski-main)
#+end_src

[[./docs/screenshots/sierpinski.png]]

* Using IUP Additional Controls

The [[https://www.tecgraf.puc-rio.br/iup/en/ctrl/iupcells.html][cells control]] "creates a grid widget (set of cells) that enables
several application-specific drawing, such as: chess tables, tiles
editors, degrade scales, drawable spreadsheets and so forth".

It's included in the standard IUP distribution downloads, but it's not
automatically loaded. The Lisp bindings do the same thing, so to use
it, we need to depend on ~IUP-CONTROLS~.

#+begin_src lisp :results silent
  (ql:quickload '("iup" "iup-controls" "cd"))
#+end_src 

#+begin_src lisp :results silent :export none :tangle examples/cells.lisp
  (defpackage #:iup-examples.cells-checkerboard
    (:use #:common-lisp)
    (:export #:cells-checkerboard))

  (in-package #:iup-examples.cells-checkerboard)
#+end_src

We start with the same boiler plate, but this time we need to call
~IUP-CONTROLS:OPEN~ ahead of using the cells control.

#+begin_src lisp :results silent :tangle examples/cells.lisp
  (defun cells-checkerboard ()
    (iup:with-iup ()
      (iup-controls:open)
      (let* ((cells (iup-controls:cells
		     :draw_cb 'draw
		     :width_cb 'width
		     :height_cb 'height
		     :nlines_cb 'nlines
		     :ncols_cb 'ncols
		     :mouseclick_cb 'click))
	     (vbox (iup:vbox (list cells)))
	     (dialog (iup:dialog vbox :title "Cells Checkerboard" :rastersize "440x480" :shrink "YES")))
	(iup:show-xy dialog iup:+center+ iup:+center+)
	(iup:main-loop))))
#+end_src

Cells has a number of callbacks related rows, columns, sizing etc.

#+begin_src lisp :results silent :tangle examples/cells.lisp
  (defun nlines (handle) 8)
  (defun ncols (handle) 8)
  (defun height (handle i) 50)
  (defun width (handle j) 50)
#+end_src

When ~DRAW~ is called, we get a canvas on which to draw:

#+begin_src lisp :results silent :tangle examples/cells.lisp
  (defun draw (handle i j xmin xmax ymin ymax canvas)
    (if (or (and (oddp i) (oddp j)) (and (oddp (1+ i)) (oddp (1+ j))))
	(setf (cd:foreground canvas) cd:+black+)
	(setf (cd:foreground canvas) cd:+white+))
    (cd:box canvas xmin xmax ymin ymax)
    iup::+default+)
#+end_src

When out click callback is called:

#+begin_src lisp :results silent :tangle examples/cells.lisp
  (defun click (handle button pressed line column x y status)
    (iup:message
     "Clicked!"
     (format nil "Callback arguments~%~S"
      (list :button button
	    :pressed pressed
	    :line line
	    :column column
	    :x x
	    :y y
	    :status (iup:status-plist status))))
       iup:+default+)
#+end_src

#+begin_src lisp :results silent
  (cells-checkerboard)
#+end_src

[[./docs/screenshots/checkerboard-01.png]]
[[./docs/screenshots/checkerboard-02.png]]

(lol button 49)

* Tabs Example

Demonstrates the use of ~(SETF IUP:ATTRIBUTE)~ for setting attributes
not available via control's constructor function.

#+begin_src lisp :results silent :export none :tangle examples/tabs.lisp
  (defpackage #:iup-examples.tabs
    (:use #:common-lisp)
    (:export #:tabs))

  (in-package #:iup-examples.tabs)
#+end_src

#+begin_src lisp :results silent :tangle examples/tabs.lisp
  (defun tabs ()
    (iup:with-iup ()
      (let* ((vbox1 (iup:vbox
		     (list (iup:label :title "Inside Tab A")
			   (iup:button :title "Button A"))))
	     (vbox2 (iup:vbox
		     (list (iup:label :title "Inside Tab B")
			   (iup:button :title "Button B"))))
	     (tabs1 (iup:tabs (list vbox1 vbox2)))
	     (vbox3 (iup:vbox
		     (list (iup:label :title "Inside C")
			   (iup:button :title "Button C"))))
	     (vbox4 (iup:vbox
		     (list (iup:label :title "Inside D")
			   (iup:button :title "Button D"))))
	     (tabs2 (iup:tabs (list vbox3 vbox4)))
	     (box (iup:hbox (list tabs1 tabs2) :margin "10x10" :gap "10"))
	     (dialog (iup:dialog box :title "IUP Tabs" :size "200x80")))
	(setf (iup:attribute vbox1 :tabtitle) "Tab A"
	      (iup:attribute vbox2 :tabtitle) "Tab B"
	      (iup:attribute vbox3 :tabtitle) "Tab C"
	      (iup:attribute vbox4 :tabtitle) "Tab D")
	(iup:show-xy dialog iup:+center+ iup:+center+)
	(iup:main-loop))))
#+end_src

#+begin_src lisp :results silent :export none
  (tabs)
#+end_src 

[[./docs/screenshots/tabs-01.png]] [[./docs/screenshots/tabs-02.png]]

